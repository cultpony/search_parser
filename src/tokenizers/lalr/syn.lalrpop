use std::str::FromStr;
use crate::ast::{Expr, Value, Comp, Field, Tag, CombOp};

grammar;

pub Expr: Expr = {
    BoolExpr,
    "(" <AndGroup> ")" => Expr::Combine(CombOp::And, <>),
    "(" <OrGroup> ")" => Expr::Combine(CombOp::Or, <>),
}

AndGroup: Vec<Expr> = {
    Expr => vec![<>],
    <a:Expr> And <b:Expr> => vec![a, b],
    <a:Expr> And <b:AndGroup> => {
        b.push(a);
        b
    },
}

OrGroup: Vec<Expr> = {
    <a:Expr> Or <b:Expr> => vec![a, b],
    <a:Expr> Or <b:OrGroup> => {
        b.push(a);
        b
    }
}

BoolExpr: Expr = {
    Tag => Expr::Tag(<>),
    <f:Field> <c:Comp> <v:Value> => Expr::Comparison(f, c, v),
}

And: CombOp = {
    "AND" => CombOp::And,
    "&&" => CombOp::And,
    "," => CombOp::And,
}

Or: CombOp = {
    "||" => CombOp::Or,
    "OR" => CombOp::Or,
}

Comp: Comp = {
    "lt:" => Comp::LessThan,
    "gt:" => Comp::GreaterThan,
    "lte:" => Comp::LessThanOrEqual,
    "gte:" => Comp::GreaterThanOrEqual,
    "neq:" => Comp::NotEqual,
    "eq:" => Comp::Equal,
}

Value: Value = {
    r"[+-]{0,1}\d+" => Value::Integer(i128::from_str(<>).unwrap()),
    r"[+-]{0,1}\d+\.\d+" => Value::Float(f64::from_str(<>).unwrap()),
    "true" => Value::Bool(true),
    "false" => Value::Bool(false),
    "yes" => Value::Bool(true),
    "no" => Value::Bool(true),
}

Tag: Tag = {
    r#"[a-z][a-z0-9]+"# => (<>).to_string()
    //<"tag"> => (<>).to_string(),
}

Field: Field = {
    r#"[a-z]+\."# => (<>).to_string()
    //<"field"> => (<>).to_string(),
}